type LeveragedPool @entity {
  id: ID! # address
  name: String!
  keeper: Bytes! # address
  committer: Bytes! # address
  longToken: Bytes! # address
  shortToken: Bytes! # address
  quoteToken: Bytes! # address
  quoteTokenDecimals: BigInt! # address
  oracle: Bytes! # address
  feeReceiver: Bytes! # address
  frontRunningInterval: BigInt!
  tradingFee: Bytes!
  updateInterval: BigInt!
  lastPriceTimestamp: BigInt!
  paused: Boolean!
  shortBalance: BigInt!
  longBalance: BigInt!
  # upkeeps: [Upkeep!]! @derivedFrom(field: "pool") # TODO add this
}

type PoolFactory @entity {
  id: ID!
  poolsCount: BigInt! # number of pools deployed
}

type Upkeep @entity {
  id: ID! # poolAddress-timestamp
  pool: LeveragedPool! # address
  txnHash: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  startPrice: BigInt!
  endPrice: BigInt!
  longTokenBalance: BigInt!
  shortTokenBalance: BigInt!
  longTokenSupply: BigInt!
  shortTokenSupply: BigInt!
  # gasPaid: BigInt! # TODO add this
}

type KeeperPayment @entity {
  id: ID! # txn hash
  pool: LeveragedPool! # address
  rewardedKeeper: Bytes! # address
  timestamp: BigInt!
  upkeepRound: Upkeep!
  amount: BigDecimal! # reward payed in settlement tokens
}

type Commit @entity {
  id: ID! # trader-committerAddress-commitId
  trader: Bytes!
  created: BigInt! # timestamp
  txnHash: Bytes!
  pool: Bytes! # address
  type: CommitType!
  amount: BigInt!
  longBalanceAtExecution: BigInt
  shortBalanceAtExecution: BigInt
  longSupplyAtExecution: BigInt
  shortSupplyAtExecution: BigInt
  executedAtBlock: BigInt
  executedAtTimestamp: BigInt
}

type LeveragedPoolByPoolCommitter @entity {
  id: ID! # pool committer address
  pool: Bytes!
}

type PoolRebalance @entity {
  id: ID! # poolAddress-blocknumber
  pool: Bytes! # pool address
  blockNumber: BigInt!
  shortBalanceChange: BigInt!
  longBalanceChange: BigInt!
}

# this is a bit of a hack to allow updating of commits
# on executeCommitment call handler
# this is because commits are deleted after they are executed
# so we use this as a way to store pending commit details
# and be able to look them up during executeCommitment handler
type CommitResolver @entity {
  id: ID! #committerAddress-commitId
  commitId: String! # trader-committerAddress-commitId
}

enum CommitType {
  ShortMint
  ShortBurn
  LongMint
  LongBurn
}
